# -*- coding: utf-8 -*-
"""Direct_Tx.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NvPeTDF8i-oq2loEzF7TjBtSgkTGqERL
"""

import networkx as nx
import matplotlib.pyplot as plt
import random
from math import *
import numpy as np
import copy
import threading
import time
import scipy.stats
import pandas as pd
import itertools
from itertools import chain
from collections import Counter
import queue
from collections import defaultdict
from datetime import datetime


#logistic function for displaying the created networkx graph
def printGraph(gra):
  fig, ax = plt.subplots(figsize=(20, 10))
  posi = dict()
  for nds in range(gra.number_of_nodes()):
    posi[nds] = gra.nodes[nds]['pos'] #tupples (x,y)
  nx.draw(gra,posi, with_labels = True, **{'node_color' : 'orange', 'node_size' : 400})

#heuristic function for calculating the air-distance between two nodes in the snapshot of the network
def heuristicAirDistance(graph, node1, node2):
  airDist = np.linalg.norm(np.array(graph.nodes[node1]['pos'])-np.array(graph.nodes[node2]['pos']))
  return (airDist)

#function to initialise the reward and q-table
def rAndQs(graph, goalNode):
  n = graph.number_of_nodes()
  hW = 0.7

  #initialising the reward values for every state-action pair according to heuristic algorithm discussed in the paper
  global R
  R= np.zeros(shape = (n,n))
  for u in range(n) :
    for v in graph[u]:
      R[u][v] = (1/( hW*heuristicAirDistance(graph,v,goalNode) + (1-hW)*heuristicAirDistance(graph,u,v) ) )

  for v in graph[goalNode] :
    R[v][goalNode] = R[v][goalNode] + 100

  #Qtable initialisation
  global Q
  Q= np.zeros(shape = (n,n))
  Q -= 200
  for nds in range(n):
    for nbs in graph[nds]:
      Q[nds][nbs] = 0
      Q[nbs][nds] = 0

  return

#function to select the next state/action for a given state according to the exploration rate
def nextState(graph, startNode, exploreRate):
  #action following exploration
  if (random.random()<=exploreRate):
    sample = list(dict(graph[startNode]).keys())

  #action following exploitation
  else :
    sample = np.where(Q[startNode,] == np.max(Q[startNode,]))[0]

  nextNode = int(random.choice(sample))

  return nextNode

#function to update the Qtable for a given state-action pair
def updateQs(node1, node2, alpha, discount):
  #calculating the future discounted reward
  futureSample = np.where(Q[node2,] == np.max(Q[node2,]))[0]
  if futureSample.shape[0] > 1:
    futureNextState = int(random.choice(futureSample))
  else :
    futureNextState = int(futureSample)
  maxValue = Q[node2,futureNextState]

  #Updating the qtable according to the reinforcement learning algorithm explained in the paper
  Q[node1,node2] = ((1-alpha)*Q[node1,node2] + alpha*(R[node1,node2] + discount*maxValue))

#function that initialises and deploys the qlearning agent
def qLearnModel(graph, goalNode, exploreRate, alpha, discount):
  rAndQs(graph, goalNode)

  n = graph.number_of_nodes()

  #Training the qlearning agent for 80000 epochs
  for i in range(80000):
    start = random.randint(0,n-1)
    if len(graph[start]) >=1 :
      #setting the decaying learning rate
      alpha = alpha**(0.85 * (i//1000))
      nextNode = nextState(graph, start, exploreRate)
      updateQs(start, nextNode, alpha, discount)

  return Q



#Function that deploys the Dynamic LPWAN Network and also the qlearning agent on it to extract qtable for each snapshot of the graph
def FspatGraph(N, limit, goalNode = 0, distribution = "poisson", printGraph = True, embarkingNow = True, previousG = None, probOfMobilizing = 1.0, exploreRate = 0.5, alpha = 0.8, discount = 0.8):

  #Creating the network for the first snapshot of the network
  if embarkingNow == True :
    global spatG
    spatG = nx.Graph()
    points = []

    #creating the IoD nodes
    for nodes in range(N):
      points.append(nodes)
    #[0,1,2,3,4,5,6...,N-1]

    #setting the IoD nodes positions according to poisson distribution
    global pos
    pos = dict()

    for nd in range(N):
      if nd == goalNode :
        pos[nd] = [2000,2000]
      elif distribution == "random":
        pos[nd] = [random.uniform(0,300), random.uniform(0,300)]

      elif distribution == "normal":
        Mean = 0
        SD = 100
        pos[nd] = [Mean+np.random.normal(0,1)*SD, Mean+np.random.normal(0,1)*SD]
      elif distribution == "poisson":
        xMin, xMax, yMin, yMax = 0, 4000, 0, 4000
        xDelta=xMax-xMin
        yDelta=yMax-yMin
        areaTotal=xDelta*yDelta

        lambda0=2; #intensity (ie mean density) of the Poisson process
        xx = xDelta*scipy.stats.uniform.rvs(0,1, size =1 )+xMin#x coordinates of Poisson points
        yy = yDelta*scipy.stats.uniform.rvs(0,1, size = 1) +yMin#y coordinates of Poisson points

        pos[nd] = [*xx, *yy]  #unpacking of list xx and yy

      spatG.add_node(nd,pos = pos[nd])
      #1st snapshot

  else:
    #taking the node positions from previous snapshot of the network
    N = previousG.number_of_nodes()
    pos = dict()

    #determining the probability of mobility of IoD devices according to probability distribution
    shift = []
    for i in range(N):
      if i != goalNode :
        shift.append(random.random())
      else :
        shift.append(2)

    shift = [p<=probOfMobilizing for p in shift]
    previousG.remove_edges_from(previousG.edges())

    #determining the random position of the IoD in future snapshot within the radio range
    for nd in range(N):
      pos[nd] = previousG.nodes[nd]['pos']
      if shift[nd] == 1:
        previousX = previousG.nodes[nd]['pos'][0]
        previousY = previousG.nodes[nd]['pos'][1]

        newX = random.uniform(previousX-limit, previousX + limit)
        while newX >= 4000 :
          newX = random.uniform(previousX-limit, previousX + limit)

        yLowLimit = -1*( ( limit**2 - (newX-previousX)**2 )**0.5) + previousY  # "Y" coord should lie within circle of radius equal to limit.
        yHighLimit =  ( limit**2 - (newX-previousX)**2 )**0.5 + previousY
        newY = random.uniform( yLowLimit , yHighLimit )
        while newY >= 4000 :
          yLowLimit = -1*( ( limit**2 - (newX-previousX)**2 )**0.5) + previousY
          yHighLimit =  ( limit**2 - (newX-previousX)**2 )**0.5 + previousY
          newY = random.uniform( yLowLimit , yHighLimit )

        previousG.nodes[nd]['pos'] = [newX, newY]
        pos[nd] = [newX, newY]

    spatG = previousG

  dist = np.empty((N,N))

  #calculating changed distances and edge connections between the moves IoDs
  connects = []
  for u in range(dist.shape[0]):
    for v in range(dist.shape[1]):
      point1 = np.array(spatG.nodes[u]['pos'])
      point2 = np.array(spatG.nodes[v]['pos'])

      dist[u][v] = np.linalg.norm(point1-point2)
      dist[u][v] = (dist[u][v]<=limit)*dist[u][v]

      if dist[u][v] != 0:
        connects.append((u,v, dist[u][v])) # list of tupples --->  connects

  spatG.add_weighted_edges_from(connects)

  #Displaying the snapshot of the graph
  if printGraph == True :
    fig, ax = plt.subplots(figsize=(20, 10))
    nx.draw(spatG,pos, with_labels = True, **{'node_color' : 'orange', 'node_size' : 400})

  #Deploying and extracting the Qtable of each of the snapshot of the network
  qTable = qLearnModel(spatG, goalNode, exploreRate, alpha, discount)


  #storing the qtable values in individual nodes
  for nds in range(N):
    qChunk = {}
    for nbs in spatG[nds]:
      qChunk[nbs] = qTable[nds][nbs]

    spatG.nodes[nds]['qChunk'] =  qChunk


  for nds in range(N):
    alloted_queue = {}
    if nds == 0:
      max_ele = 20000
      alloted_queue[0] = queue.Queue(maxsize = max_ele)

    else:
      max_ele = 200
      alloted_queue[nds] = queue.Queue(maxsize = max_ele)

    spatG.nodes[nds]['alloted_queue'] =  alloted_queue

  # print(list(spatG.nodes[10]['alloted_queue'][10].queue))

  return spatG, pos, qTable


#################################################################### Graph Creation Ends Here ###########################################################################################


#Energy of all the IoDs are initialised
enen=[]
enee=[]
for i in range(400):
  enen.append(i)
  enee.append(0)
ene=dict(zip(enen,enee))
for i in ene:
  ene[i]=72000
ene[0]=10000000

#function to determine the shortestpath calculation
def shortestPath1(graph, QTable, sourceNode, goalNode, cords, exploreRate=0.5, alpha=0.8, discount=0.8):

  #looking up the learned qtable for each snapshot of the network
  qTable = copy.deepcopy(QTable)
  count = 0
  tolerance = 0
  #performing the shortest path search algorithm according the residual energies of the IoD devices
  if ene[sourceNode]>1:
    path = [sourceNode]
  else:
    return [], qTable

  nextNode = np.argmax(qTable[sourceNode,])
  tic = time.time()
  toc = tic

  db = round(((sqrt(((cords[sourceNode][0]-cords[nextNode][0])**2)+((cords[sourceNode][1]-cords[nextNode][1])**2) ))),2)

  startEngDeduction = 0
  while nextNode != goalNode :

    #Condition when qtable and the residual energies of the nodes both support q-learning algorithm
    if nextNode not in path and ene[nextNode] >1:

      path.append(nextNode)
      db = round(((sqrt(((cords[path[-2]][0]-cords[nextNode][0])**2)+((cords[path[-2]][1]-cords[nextNode][1])**2) ))),2)
      startEngDeduction = 1

      #deducing the energy of transmission according to distance models
      if db<=520 and startEngDeduction != 0:
          e=0.3256*pow(10,-3)+(0.000041*pow(db,2))
          ene[path[-2]]=ene[path[-2]]-e

      elif db>520 and startEngDeduction != 0:
          e=0.3256*pow(10,-3)+((2*pow(10,-10)*pow(db,4)))
          ene[path[-2]]=ene[path[-2]]-e

      nextNode = np.argmax(qTable[nextNode,])

    #Condition when qtable best node can't be used due to low residual energy, then the next best node until 3 or less attempts is tried out
    elif (nextNode in path and tolerance == 0) or (ene[nextNode] <=1 and tolerance == 0) :
      count = 0
      while count < min(4,len(graph[path[-1]])-1) :
        count += 1
        if count == 1 :
          qChunk = {}
          for nbs in graph[path[-1]]:
            qChunk[nbs] = qTable[path[-1]][nbs]
          listOfQmax = sorted(qChunk.items(), key=lambda item: item[1], reverse = True)
          listOfQmax = [t[0] for t in listOfQmax]  #separating keys

        #chosing the next best node with required residual energy
        if ene[listOfQmax[count]]>1:
          nextNode = listOfQmax[count]

        #if next node has energy make it the next node
        if nextNode not in path and ene[nextNode] >1 :
          break
      #if no suitable IoD is selected after 3 attempts tolerance is lost and direct hop is executed
      if count >= 4 or count >= len(graph[path[-1]])-1:
        tolerance = 1

    #condition for executing a direct hop transmission
    elif (nextNode in path and tolerance == 1) or (ene[nextNode] <=1 and tolerance == 1):
      #path.append("--Kinked path to-- ")
      db = round(((sqrt(((cords[path[-1]][0]-cords[0][0])**2)+((cords[path[-1]][1]-cords[0][1])**2) ))),2)
      if db<=520 :
          e=0.3256*pow(10,-3)+(0.000041*pow(db,2))
          ene[path[-1]]=ene[path[-1]]-e

      else:
          e=0.3256*pow(10,-3)+(2*pow(10,-10)*pow(db,4))
          ene[path[-1]]=ene[path[-1]]-e

      break

  path.append(goalNode)

  return path, qTable


#logistic function to find the best exploration rate

def shortestPathConclusion(graph, sourceNode, goalNode, alpha, discount):
  sps = []
  spls =[]
  qtables = []
  exploreRates = [0.0 + i/10 for i in range(10)]

  for exploreRate in exploreRates :
    sp, qtable= shortestPath1(graph, sourceNode, goalNode, exploreRate, alpha, exploreRate)
    sps.append(sp)
    qtables.append(qtable)
    length = 0
    for i in range(len(sp)-1):
      if type(sp[i+1]) == type("str") :
        length = float('inf')
        break
      length += graph[sp[i]][sp[i+1]]['weight']
    spls.append(length)

  print("\nAll experimented paths : ", sps)
  return sps[spls.index(min(spls))], qtables[spls.index(min(spls))]


#-------------------------------------------------------------------------------------------------------------------/////////////////////////////////////////////-------------------------------
                                     #                                                                                               1111111
#-------------------------------------------------------------------------------------------------------------------/////////////////////////////////////////////-------------------------------

def direct_hop_transmission(spatGraph, nds, radioRange):
  path = []
  if ene[nds] >0:
    path.append(nds)
    path.append(0)
  db = heuristicAirDistance(spatGraph, nds, 0)
  if db <= 520:
    e=0.3256*pow(10,-3)+(0.000041*pow(db,2))
    ene[nds]=ene[nds]-e
  else:
    e=0.3256*pow(10,-3)+(2*pow(10,-10)*pow(db,4))
    ene[nds]=ene[nds]-e

  return path

#-------------------------------------------------------------------------------------------------------------------/////////////////////////////////////////////-------------------------------
                                     #                                                                                               1111111
#-------------------------------------------------------------------------------------------------------------------/////////////////////////////////////////////-------------------------------


################################################################# Functions Related To Shortest Path End Here #########################################################################


#-------------------------------------------------------------------------------------------------------------------/////////////////////////////////////////////-------------------------------
                                   #                                                                                                 2222222
#-------------------------------------------------------------------------------------------------------------------/////////////////////////////////////////////-------------------------------


# without RTS-CTS -----------------------------------------------

def is_queue_full(graph, node_id):
    queue_of_node = graph.nodes[node_id]['alloted_queue'][node_id]
    return queue_of_node.full()

def is_queue_empty(graph, node_id):
    queue_of_node = graph.nodes[node_id]['alloted_queue'][node_id]
    return queue_of_node.empty()

def transmit_data(graph,current_node, next_node, data):
    timing = 0
    tic = time.time()
    # print(f"before {current_node} ------>> {len(list(graph.nodes[current_node]['alloted_queue'][current_node].queue))}")
    list_of_data_current_node = graph.nodes[current_node]['alloted_queue'][current_node]
    put_data = list_of_data_current_node.get()


    # print(f"after {current_node} <<------ {len(list(graph.nodes[current_node]['alloted_queue'][current_node].queue))}")

    # print(f"before {next_node} ------>>  {len(list(graph.nodes[next_node]['alloted_queue'][next_node].queue))}")
    if graph.nodes[next_node]['alloted_queue'][next_node].full() == False:
      graph.nodes[next_node]['alloted_queue'][next_node].put(put_data)

    # print(f"after {next_node} <<------  {len(list(graph.nodes[next_node]['alloted_queue'][next_node].queue))}")
    # print(f"Node {current_node} transmittED data to {next_node}\n")
    toc = time.time()
    timing = toc-tic
    return timing

#-------------------------------------------------------------------------------------------------------------------/////////////////////////////////////////////-------------------------------
                     #                                                                                                               22222222
#-------------------------------------------------------------------------------------------------------------------/////////////////////////////////////////////-------------------------------



def simulate_sensor_readings():
    # Simulate temperature and humidity readings
    temperature = 20 + random.gauss(0, 5)  # Mean temperature around 20°C with some noise
    humidity = 50 + random.gauss(0, 10)  # Mean humidity around 50% with some noise
    return temperature, humidity

def get_time_of_day_factor():
    # Simulate time of day factor (day: 1, night: 0.5)
    hour = datetime.now().hour
    return 1 if 6 <= hour < 18 else 0.5

def get_battery_level():
    # Simulate battery level between 20% and 100%
    return 20 + random.random() * 80

def get_proximity_to_events():
    # Simulate proximity to events (closer: higher value)
    return random.random()

def get_weather_condition():
    # Simulate different weather conditions (clear: 1, rainy: 0.8, foggy: 0.6)
    weather_conditions = {'clear': 1, 'rainy': 0.8, 'foggy': 0.6}
    return weather_conditions[random.choice(list(weather_conditions.keys()))]

def get_node_health():
    # Simulate node health (good: 1, degraded: 0.7, bad: 0.4)
    health_status = {'good': 1, 'degraded': 0.7, 'bad': 0.4}
    return health_status[random.choice(list(health_status.keys()))]

def get_movement_vibration():
    # Simulate movement or vibration (no: 1, slight: 1.2, high: 1.5)
    movement_status = {'no': 1, 'slight': 1.2, 'high': 1.5}
    return movement_status[random.choice(list(movement_status.keys()))]

def get_node_density():
    # Simulate node density (few neighbors: 1, moderate: 0.9, high: 0.8)
    density_status = {'few': 1, 'moderate': 0.9, 'high': 0.8}
    return density_status[random.choice(list(density_status.keys()))]

def generate_data_based_on_conditions(temperature, humidity, time_of_day, battery_level, proximity, weather, health, movement, density):
    base_count = 45

    # Adjust base count based on conditions
    base_count *= time_of_day
    base_count *= (battery_level / 100)
    base_count *= (1 + proximity)
    base_count *= weather
    base_count *= health
    base_count *= movement
    base_count *= density

    # Further adjust based on temperature and humidity
    if temperature > 25 and humidity > 60:
        base_count *= 1.25
    elif temperature > 20 and humidity > 50:
        base_count *= 1.1

    return int(base_count)



global ls_tx, ls_rx
tpp = []
tpd = []
ls_rx =[]
ls_tx =[]
Gpath = {}
gen_data = []

#function to execute the dynamic LPWAN as a whole for a totalDuration's time
def executeSimulation(NumberOfNodes, radioRange, probabilityOfMobilizing, totalDuration):

  global figCount
  figCount = 1
  listOfGraphs =[]
  timingToGraph = 0

  while  timingToGraph <= totalDuration:
    tic = time.time()
    if figCount == 1:

      spatGraph,positions,qTable = FspatGraph(NumberOfNodes,radioRange, printGraph = False) #Any function

    else :

      spatGraph,positions,qTable = FspatGraph(_,radioRange, printGraph = False, embarkingNow= False, previousG= spatGraph, probOfMobilizing= probabilityOfMobilizing)

    toc = time.time()
    timingToGraph += toc-tic



#------------------------------------------------------------------------------------------///////////////////////////////////////////-------------------
#------------------------------------------------------------------------------------------///////////////////////////////////////////-------------------

#------------------------------------------------------------------------------------------///////////////////////////////////////////-------------------
#------------------------------------------------------------------------------------------///////////////////////////////////////////-------------------




#-----------------------------------------------------------------------------
    for nds in range(1,NumberOfNodes):

      temperature, humidity = simulate_sensor_readings()
      time_of_day = get_time_of_day_factor()
      battery_level = get_battery_level()
      proximity = get_proximity_to_events()
      weather = get_weather_condition()
      health = get_node_health()
      movement = get_movement_vibration()
      density = get_node_density()

      no_of_data = generate_data_based_on_conditions(temperature, humidity, time_of_day, battery_level, proximity, weather, health, movement, density)
      if no_of_data > 40:
        no_of_data = 40
      if no_of_data < 1:
        no_of_data = 1

      for i in range(no_of_data):
        spatGraph.nodes[nds]['alloted_queue'][nds].put(f"Node{nds}")

#-----------------------------------------------------------------------------
    spath={}
    for nds in range(400):
      if nds == 0 :
        continue
      if len(spatGraph[nds]) >=1 :
        # sp,_ = shortestPath1(spatGraph, qTable, nds, 0, positions) # exploreRate=0.5, alpha = 0.8, discount =0.8)
        # sp,_ = dijkstra(spatGraph, nds, 0)4
        sp = direct_hop_transmission(spatGraph, nds, radioRange)

        if len(sp)>1:
          spath[nds] =sp

    Gpath[figCount-1] = spath
    #Gpath = {0:{0:[], 1:[],  2:[]}, 1:{0:[], 1:[], 2:[]}, 2:{0:[], 1:[], 2:[]}}

    eligible_nodes = []
    eligible_nodes.append(list(spath.keys()))
    # print(eligible_nodes)

#----------------------------------------------^^^^^^^^^^^^^^^^-------------------------
    temp_queues = {}
    for nd in spatGraph.nodes:
      temp_queues[nd] = spatGraph.nodes[nd]['alloted_queue']
      del spatGraph.nodes[nd]['alloted_queue']

    gra, graPos,graQt  = copy.deepcopy(spatGraph),copy.deepcopy(positions),copy.deepcopy(qTable)

    for nd in spatGraph.nodes:
        spatGraph.nodes[nd]['alloted_queue'] = temp_queues[nd]

    listOfGraphs.append([gra, graPos, graQt])
#----------------------------------------------------------------------------

    tx_data = 0
    for nds in range(400):
      tx_data += len(list(spatGraph.nodes[nds]['alloted_queue'][nds].queue))

    for nds in range(1,400):
      print(list(spatGraph.nodes[nds]['alloted_queue'][nds].queue))
    gen_data.append(tx_data)
#-----------------------------------------------------------------------

    # remaining_data = 0
    # received = 0
    # timing= 0

    # nodes_having_data = []
    # for nds in range(1,400):
    #   if nds in eligible_nodes[0]:
    #     if is_queue_empty(spatGraph,nds) == False:
    #       nodes_having_data.append(nds)
    # print(nodes_having_data)
    #--------------------------------------------------------------------------
    timing1 = 0
    # add_time = 0
    # while timing<=(toc-tic):
    # direct_ls_tx, direct_ls_rx, direct_gen_data = direct_hop_transmission(spatGraph, NumberOfNodes, radioRange)
      # timing += add_time
      # print(timing)


    # print(direct_ls_tx)
    # print(direct_ls_rx)
    # print(direct_gen_data)

    # ls_tx.append(*direct_ls_tx)
    # ls_rx.append(*direct_ls_rx)
    # gen_data = direct_gen_data

    while timing1<=(toc-tic): #  is_queue_full(spatGraph,0) == False and remaining_data > 0 and timing<= (toc-tic)

      nodes_having_data = []
      for nds in range(1,400):
        if nds in eligible_nodes[0]:
          if is_queue_empty(spatGraph,nds) == False:
            nodes_having_data.append(nds)


      received = len(list(spatGraph.nodes[0]['alloted_queue'][0].queue))
      print(f"\n--------->> {len(list(spatGraph.nodes[0]['alloted_queue'][0].queue))} <<----- data in Goal node.------>> {tx_data} <<-----Total data-------Graphs = {figCount}\n")
      print(nodes_having_data)
      if len(nodes_having_data)>0:
        select_node = random.choice(nodes_having_data)
        nextNode = spath[select_node][1]
      else:
        break

      timing1 += transmit_data(spatGraph,select_node,nextNode, f"Data to {nextNode}")


    ls_tx.append(timing1)
    print("\n\nDONE..!")
    print(f"--------->> {len(list(spatGraph.nodes[0]['alloted_queue'][0].queue))} <<------data in Goal node.----->> {tx_data} <<-----Total data")
    ls_rx.append(len(list(spatGraph.nodes[0]['alloted_queue'][0].queue)))

  #-----------------------------------------------^^^^^^^^^^^^^^^^^^^-------------------------
    # remaining_data = 0
    # for nds in range(1,400):
    #   remaining_data += len(list(spatGraph.nodes[nds]['alloted_queue'][nds].queue))
    # print(remaining_data)

  #   for nds in range(400):
  #     print(list(spatGraph.nodes[nds]['alloted_queue'][nds].queue))

    print(ls_rx)
    print(ls_tx)
    print(gen_data)
    print("\n\n")
    figCount += 1

#----------------------------------------------------------------------------

  print("Stats :\n")
  print("\nTotal duration of the simulation set : ", totalDuration)
  print("\nTotal duration of time simulation used : ", toc-tic)
  print("\nTime taken per one screen shot of network : ", (toc-tic)/(len(listOfGraphs)))
  print("\nTotal output screen shots generated : ", len(listOfGraphs))
  # print(tpp)
  # print(tpd)
  # print(list(spatG.nodes[10]['alloted_queue'][10].queue))
  print("\n\n")

  return listOfGraphs


Graphs = executeSimulation(400,10000 , 0.4, 1000)    #(400,520 , 0.4, 1000)

# [619, 610, 597, 590, 527, 511, 463, 431, 430, 410, 381, 377, 368, 362, 358, 349, 345, 338, 329, 323, 320, 317, 314, 308, 304, 301, 297, 291, 287, 285, 282, 279, 274, 270, 268, 265, 265, 263, 259, 257, 254, 253, 252, 249, 247, 245, 244, 241, 240, 238, 234, 233, 232, 230, 227, 225, 225, 222, 222, 219, 218, 216, 215, 212, 211, 209, 207, 206, 205, 202, 201, 200, 198, 196, 196, 194, 192, 191, 189, 189, 187, 186, 185, 183, 182, 181, 179, 179, 178, 176, 176, 173, 173, 172, 171, 170, 168, 168, 165, 165, 163, 163, 161, 160, 159, 159, 158, 157, 156, 155, 154, 153, 153, 151, 149, 150, 148, 149, 147, 146, 146, 145, 144, 143, 142, 141, 140, 141, 138, 138, 138, 136, 137, 135, 135, 133, 132, 131, 131, 130, 129, 129, 127, 128, 127, 127, 125, 124, 124, 123, 124, 122, 122, 120, 121, 120, 119, 118, 118, 117, 116, 115, 115, 114, 113, 114, 113, 112, 113, 111, 110, 109, 110, 109, 108, 109, 107, 108, 107, 106, 105, 104, 104, 104, 103, 102, 103, 103, 101, 100, 100, 99, 99, 97, 97, 96, 97, 97, 96, 94, 94, 93, 92]
# [0.019317626953125, 0.019967079162597656, 0.018098831176757812, 0.014601945877075195, 0.010216474533081055, 0.008880853652954102, 0.008055686950683594, 0.0071184635162353516, 0.00864100456237793, 0.00613093376159668, 0.005743741989135742, 0.004354715347290039, 0.004577159881591797, 0.0037865638732910156, 0.0037393569946289062, 0.003323793411254883, 0.003180265426635742, 0.0026047229766845703, 0.002743959426879883, 0.002209901809692383, 0.001989126205444336, 0.0021653175354003906, 0.0015811920166015625, 0.0020058155059814453, 0.0018815994262695312, 0.002247333526611328, 0.0020418167114257812, 0.0013184547424316406, 0.0012934207916259766, 0.0016829967498779297, 0.0014376640319824219, 0.0013895034790039062, 0.0011570453643798828, 0.001199483871459961, 0.0009245872497558594, 0.0011034011840820312, 0.0013728141784667969, 0.0007996559143066406, 0.0014433860778808594, 0.0012049674987792969, 0.0008728504180908203, 0.0011565685272216797, 0.001066446304321289, 0.0010073184967041016, 0.0008008480072021484, 0.0009250640869140625, 0.0006992816925048828, 0.0008976459503173828, 0.0007913112640380859, 0.0008220672607421875, 0.0006334781646728516, 0.0009016990661621094, 0.0008823871612548828, 0.0008089542388916016, 0.0007090568542480469, 0.0008380413055419922, 0.0010843276977539062, 0.0007550716400146484, 0.000736236572265625, 0.0007812976837158203, 0.0011050701141357422, 0.0014119148254394531, 0.0010700225830078125, 0.00116729736328125, 0.0022318363189697266, 0.0010294914245605469, 0.0008656978607177734, 0.0005564689636230469, 0.0012559890747070312, 0.0007405281066894531, 0.0007009506225585938, 0.0005495548248291016, 0.00046896934509277344, 0.0005710124969482422, 0.0005185604095458984, 0.0006163120269775391, 0.0006206035614013672, 0.0006885528564453125, 0.00042438507080078125, 0.0005397796630859375, 0.0006647109985351562, 0.0005764961242675781, 0.0004849433898925781, 0.0005362033843994141, 0.0005669593811035156, 0.0006344318389892578, 0.0005347728729248047, 0.0006222724914550781, 0.00038170814514160156, 0.0003604888916015625, 0.0004875659942626953, 0.0006327629089355469, 0.000499725341796875, 0.0006909370422363281, 0.0005240440368652344, 0.0005698204040527344, 0.0005638599395751953, 0.0005953311920166016, 0.0006144046783447266, 0.0005483627319335938, 0.0006542205810546875, 0.0004456043243408203, 0.0005931854248046875, 0.0005562305450439453, 0.0005271434783935547, 0.0004773139953613281, 0.0004165172576904297, 0.0006394386291503906, 0.0003848075866699219, 0.00038909912109375, 0.0006704330444335938, 0.00045609474182128906, 0.00039196014404296875, 0.00039696693420410156, 0.0005254745483398438, 0.0005755424499511719, 0.0004258155822753906, 0.0005285739898681641, 0.0006113052368164062, 0.0004055500030517578, 0.0004665851593017578, 0.0006575584411621094, 0.0007936954498291016, 0.00045037269592285156, 0.0005233287811279297, 0.0003955364227294922, 0.00038242340087890625, 0.0004451274871826172, 0.0006825923919677734, 0.0008361339569091797, 0.0006151199340820312, 0.0005199909210205078, 0.0004322528839111328, 0.00033092498779296875, 0.0003421306610107422, 0.0003924369812011719, 0.0002734661102294922, 0.00043272972106933594, 0.00038433074951171875, 0.0003421306610107422, 0.00038504600524902344, 0.0002548694610595703, 0.0002720355987548828, 0.0004684925079345703, 0.0004146099090576172, 0.0002834796905517578, 0.00034236907958984375, 0.0003273487091064453, 0.0004608631134033203, 0.00026035308837890625, 0.0004706382751464844, 0.00037026405334472656, 0.00035953521728515625, 0.0004987716674804688, 0.0004718303680419922, 0.0003247261047363281, 0.0003135204315185547, 0.00043845176696777344, 0.0003724098205566406, 0.0003757476806640625, 0.0005061626434326172, 0.0004661083221435547, 0.0002541542053222656, 0.0003292560577392578, 0.0003676414489746094, 0.00025844573974609375, 0.00034117698669433594, 0.00030350685119628906, 0.00022745132446289062, 0.00046324729919433594, 0.0004596710205078125, 0.000286102294921875, 0.0004360675811767578, 0.0003249645233154297, 0.00018405914306640625, 0.00020194053649902344, 0.0002663135528564453, 0.00011539459228515625, 0.00019288063049316406, 0.00020956993103027344, 0.00023293495178222656, 0.00020265579223632812, 0.0002510547637939453, 0.00022935867309570312, 0.00024247169494628906, 0.0002384185791015625, 0.0001862049102783203, 0.000194549560546875, 0.00015878677368164062, 0.0002243518829345703, 0.0004372596740722656, 0.0003180503845214844, 0.00018596649169921875, 0.00020265579223632812, 0.00023651123046875, 0.0002727508544921875, 0.00030493736267089844, 0.00026726722717285156, 0.00022673606872558594, 0.00025773048400878906, 0.00012564659118652344, 0.00016236305236816406, 0.0005154609680175781, 0.0001857280731201172]
# [768, 710, 719, 748, 743, 708, 789, 746, 716, 770, 756, 753, 745, 749, 747, 750, 772, 729, 761, 748, 719, 728, 749, 760, 754, 727, 763, 753, 749, 703, 780, 739, 732, 744, 755, 738, 720, 717, 756, 775, 739, 768, 756, 713, 751, 708, 759, 744, 760, 753, 715, 749, 747, 712, 717, 748, 722, 702, 715, 768, 782, 758, 739, 772, 759, 730, 726, 743, 757, 729, 731, 731, 727, 735, 749, 748, 770, 772, 734, 746, 743, 721, 754, 716, 736, 780, 731, 741, 755, 739, 752, 731, 747, 727, 780, 756, 737, 778, 736, 738, 735, 742, 755, 732, 728, 738, 761, 750, 732, 706, 722, 736, 763, 741, 741, 747, 738, 722, 719, 735, 728, 730, 748, 745, 742, 754, 724, 709, 750, 723, 762, 734, 743, 729, 729, 757, 753, 732, 751, 734, 756, 727, 760, 715, 754, 747, 742, 744, 763, 678, 722, 712, 739, 711, 748, 748, 716, 726, 729, 735, 705, 734, 704, 748, 763, 797, 739, 747, 749, 735, 702, 744, 725, 722, 721, 740, 791, 769, 720, 774, 680, 765, 763, 754, 757, 776, 735, 738, 737, 683, 765, 700, 710, 737, 745, 705, 746, 740, 757, 717, 742, 763, 739, 717]